Index: 3rdparty/libav_Mat/src/libav.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"libav.hpp\"\n\n#include <boost/endian/conversion.hpp>\n#include <iostream>\n#include <regex>\n\n#ifdef USE_ROS\nLibAV::LibAV(ros::NodeHandle* nh, std::string src, int flag, std::string topic,\n             int buffer_size)\n    : mode_(flag) {\n  nh_ = nh;\n  it_ = new image_transport::ImageTransport(*nh_);\n  img_pub_ = it_->advertise(topic, 1);\n\n  switch (flag) {\n    case NORMAL_STREAM:\n      initAV(src, buffer_size);\n      break;\n    case UDP_STREAM:\n      groupUDP(src);\n      end_of_stream_ = true;\n      initIOAV(buffer_size);\n      break;\n    default:\n      initAV(src, buffer_size);\n      break;\n  }\n}\n#endif\n\nLibAV::LibAV(std::string src, int flag, std::string topic, int buffer_size)\n    : mode_(flag) {\n#ifdef USE_ROS\n  // ROS init\n  nh_ = new ros::NodeHandle();\n  it_ = new image_transport::ImageTransport(*nh_);\n  img_pub_ = it_->advertise(topic, 1);\n#endif\n\n  switch (flag) {\n    case NORMAL_STREAM:\n      initAV(src, buffer_size);\n      break;\n    case UDP_STREAM:\n      groupUDP(src);\n      end_of_stream_ = true;\n      initIOAV(buffer_size);\n      break;\n    case MANUAL_IO:\n      end_of_stream_ = true;\n      initIOAV(buffer_size);\n      break;\n    default:\n      initAV(src, buffer_size);\n      break;\n  }\n}\n\nLibAV::~LibAV() {\n  av_frame_free(&decframe_);\n  av_frame_free(&frame_);\n  avcodec_close(vstrm_->codec);\n  avformat_close_input(&inctx_);\n}\n\nint LibAV::groupUDP(std::string& uri) {\n  std::smatch result;\n  std::regex pattern(\"udp://(.+):(\\\\d+)\");\n\n  if (!std::regex_match(uri, result, pattern)) {\n    std::cerr << \"Only support UDP protocol now. Please check uri input like \"\n                 \"udp://127.0.0.1:8000\"\n              << std::endl;\n    exit(-1);\n  } else {\n    std::string tmp = \"\";\n    udp_.bindServer(tmp, std::stoi(result[2]));\n    tmp = result[1];\n    udp_.joinGroup(tmp);\n    udp_t_ = new std::thread([this] {\n      std::vector<uint8_t> buf;\n      while (1) {\n        udp_.recvFromGroup(buf);\n        if (!buf.size()) continue;\n        // Filter for 716 image\n        if (buf[0] == 0xee && buf[1] == 0x16) {\n          // Get RGB image only\n          if (buf.size() < 4 || buf[3] != 0xd6) continue;\n          {\n            // Append received buffer to global buffer\n            saveToBuffer(buf, 6);\n          }\n        }\n      }\n    });\n  }\n}\n\nint LibAV::initIOAV(int buffer_size) {\n  av_register_all();\n  io_buffer_ = NULL;\n\n  AVInputFormat* in_fmt = av_find_input_format(\"h264\");\n\n  udp_buffer_.clear();\n\n  io_buffer_ = (unsigned char*)av_malloc(buffer_size);\n\n  /* Read data */\n  avio_ctx_ = avio_alloc_context(io_buffer_, buffer_size, 0, this,\n                                 LibAV::readPacket, NULL, NULL);\n\n  inctx_ = avformat_alloc_context();\n\n  inctx_->pb = avio_ctx_;\n  inctx_->flags = AVFMT_FLAG_CUSTOM_IO;\n  while (udp_buffer_.size() < 80000) {\n    std::cout<<\"waiting for data\"<<std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n\n  /* Allocate format context */\n  int ret = avformat_open_input(&inctx_, NULL, in_fmt, NULL);\n  if (ret < 0) {\n    std::cerr << \"Could not open input: \" << std::oct << ret << std::endl;\n    return -1;\n  }\n  while (udp_buffer_.size() < 80000) {\n    std::cout<<\"waiting for data\"<<std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n  // Retrive input stream information\n  ret = avformat_find_stream_info(inctx_, nullptr);\n  if (ret < 0) {\n    std::cerr << \"Failed to find stream info. ret=\" << ret;\n    return 2;\n  }\n\n  while (udp_buffer_.size() < 100000) {\n    std::cout<<\"waiting for data\"<<std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n  // Find primary Video stream\n  AVCodec* vcodec = nullptr;\n  ret = av_find_best_stream(inctx_, AVMEDIA_TYPE_VIDEO, -1, -1, &vcodec, 0);\n  if (ret < 0) {\n    std::cerr << \"Fail to find best stream. ret=\" << ret;\n    return 3;\n  }\n  vstrm_idx_ = ret;\n  vstrm_ = inctx_->streams[vstrm_idx_];\n\n  while (udp_buffer_.size() < 500000) {\n    std::cout<<\"waiting for data\"<<std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n  // Open video decoder context\n  ret = avcodec_open2(vstrm_->codec, vcodec, nullptr);\n  if (ret < 0) {\n    std::cerr << \"Fail to open decoder. ret=\" << ret;\n    return 4;\n  }\n\n  // Print input video stream informataion\n  std::cout << \"format: \" << inctx_->iformat->name << \"\\n\"\n            << \"vcodec: \" << vcodec->name << \"\\n\"\n            << \"size:   \" << vstrm_->codec->width << 'x'\n            << vstrm_->codec->height << \"\\n\"\n            << \"fps:    \" << av_q2d(vstrm_->codec->framerate) << \" [fps]\\n\"\n            << \"length: \"\n            << av_rescale_q(vstrm_->duration, vstrm_->time_base, {1, 1000}) /\n                   1000.\n            << \" [sec]\\n\"\n            << \"pixfmt: \" << av_get_pix_fmt_name(vstrm_->codec->pix_fmt) << \"\\n\"\n            << \"frame:  \" << vstrm_->nb_frames << \"\\n\"\n            << std::flush;\n\n  // Initialize sample scaler\n  dst_width_ = vstrm_->codec->width;\n  dst_height_ = vstrm_->codec->height;\n  const AVPixelFormat dst_pix_fmt = AV_PIX_FMT_BGR24;\n  swsctx_ =\n      sws_getCachedContext(nullptr, vstrm_->codec->width, vstrm_->codec->height,\n                           vstrm_->codec->pix_fmt, dst_width_, dst_height_,\n                           dst_pix_fmt, SWS_BICUBIC, nullptr, nullptr, nullptr);\n  if (!swsctx_) {\n    std::cerr << \"Fail to get sws cached context.\";\n    exit(5);\n  }\n  std::cout << \"output: \" << dst_width_ << 'x' << dst_height_ << ','\n            << av_get_pix_fmt_name(dst_pix_fmt) << std::endl;\n  // Allocate frame buffer for output\n  frame_ = av_frame_alloc();\n  framebuf_.resize(avpicture_get_size(dst_pix_fmt, dst_width_, dst_height_));\n  avpicture_fill(reinterpret_cast<AVPicture*>(frame_), framebuf_.data(),\n                 dst_pix_fmt, dst_width_, dst_height_);\n\n  decframe_ = av_frame_alloc();\n  end_of_stream_ = false;\n\n  udp_buffer_.clear();\n  stream_th_ = new std::thread(&LibAV::openThread, this);\n}\n\nint LibAV::initAV(std::string& src, int buffer_size) {\n  // Initialize FFmpeg library\n  av_register_all();\n  int ret;\n\n  avformat_network_init();\n  if (!(inctx_ = avformat_alloc_context())) {\n    ret = AVERROR(ENOMEM);\n    return -1;\n  }\n  // inctx_->flags|=AVFMT_FLAG_NOBUFFER;\n  inctx_->flags |= AVFMT_FLAG_FLUSH_PACKETS;\n\n  // Set options for different streams\n  AVDictionary* options = NULL;\n  if (std::regex_match(src, std::regex(\"^rtsp://.*\"))) {\n    av_dict_set_int(&options, \"buffer_size\", buffer_size, 0);\n  }\n\n  // Open input and read its header\n  ret = avformat_open_input(&inctx_, src.c_str(), nullptr, &options);\n  if (ret < 0) {\n    std::cerr << \"Failed to open \" << src << \". ret=\" << ret;\n    return 1;\n  }\n  av_dict_free(&options);\n  // Retrive input stream information\n  ret = avformat_find_stream_info(inctx_, nullptr);\n  if (ret < 0) {\n    std::cerr << \"Failed to find stream info. ret=\" << ret;\n    return 2;\n  }\n  av_dump_format(inctx_, 0, \"\", 0);\n  // Find primary Video stream\n  AVCodec* vcodec = nullptr;\n  ret = av_find_best_stream(inctx_, AVMEDIA_TYPE_VIDEO, -1, -1, &vcodec, 0);\n  if (ret < 0) {\n    std::cerr << \"Fail to find best stream. ret=\" << ret;\n    return 3;\n  }\n  vstrm_idx_ = ret;\n  vstrm_ = inctx_->streams[vstrm_idx_];\n  // Open video decoder context\n  ret = avcodec_open2(vstrm_->codec, vcodec, nullptr);\n  if (ret < 0) {\n    std::cerr << \"Fail to open decoder. ret=\" << ret;\n    return 4;\n  }\n\n  // Print input video stream informataion\n  std::cout << \"infile: \" << src << \"\\n\"\n            << \"format: \" << inctx_->iformat->name << \"\\n\"\n            << \"vcodec: \" << vcodec->name << \"\\n\"\n            << \"size:   \" << vstrm_->codec->width << 'x'\n            << vstrm_->codec->height << \"\\n\"\n            << \"fps:    \" << av_q2d(vstrm_->codec->framerate) << \" [fps]\\n\"\n            << \"length: \"\n            << av_rescale_q(vstrm_->duration, vstrm_->time_base, {1, 1000}) /\n                   1000.\n            << \" [sec]\\n\"\n            << \"pixfmt: \" << av_get_pix_fmt_name(vstrm_->codec->pix_fmt) << \"\\n\"\n            << \"frame:  \" << vstrm_->nb_frames << \"\\n\"\n            << std::flush;\n\n  // Initialize sample scaler\n  dst_width_ = vstrm_->codec->width;\n  dst_height_ = vstrm_->codec->height;\n  const AVPixelFormat dst_pix_fmt = AV_PIX_FMT_BGR24;\n  swsctx_ =\n      sws_getCachedContext(nullptr, vstrm_->codec->width, vstrm_->codec->height,\n                           vstrm_->codec->pix_fmt, dst_width_, dst_height_,\n                           dst_pix_fmt, SWS_BICUBIC, nullptr, nullptr, nullptr);\n  if (!swsctx_) {\n    std::cerr << \"Fail to get sws cached context.\";\n    exit(5);\n  }\n  std::cout << \"output: \" << dst_width_ << 'x' << dst_height_ << ','\n            << av_get_pix_fmt_name(dst_pix_fmt) << std::endl;\n  // Allocate frame buffer for output\n  frame_ = av_frame_alloc();\n  framebuf_.resize(avpicture_get_size(dst_pix_fmt, dst_width_, dst_height_));\n  avpicture_fill(reinterpret_cast<AVPicture*>(frame_), framebuf_.data(),\n                 dst_pix_fmt, dst_width_, dst_height_);\n\n  decframe_ = av_frame_alloc();\n  end_of_stream_ = false;\n\n  stream_th_ = new std::thread(&LibAV::openThread, this);\n}\n\nvoid LibAV::saveToBuffer(std::vector<uint8_t>& buf, int offset) {\n  std::lock_guard<std::mutex> lock(buf_lock_);\n  if (udp_buffer_.size() > 5000000) udp_buffer_.clear();\n  udp_buffer_.insert(udp_buffer_.end(), buf.begin() + offset, buf.end());\n}\n\nint LibAV::readPacket(void* opaque, uint8_t* buf, int buf_size) {\n  LibAV* p = (LibAV*)opaque;\n  if (p == NULL) {\n    return -1;\n  }\n\n  std::lock_guard<std::mutex> lock(p->buf_lock_);\n  buf_size = std::min(buf_size, int(p->udp_buffer_.size()));\n\n  if (p->udp_buffer_.size() == 0) return 0;\n  if (!buf_size) {\n    return AVERROR_UNKNOWN;\n  }\n\n  // std::cout << \"\\033[36mbuffer size: \" << p->udp_buffer_.size() << \" \\033[0m\"\n  //           << std::endl;\n  /* copy internal buffer data to buf */\n  memcpy(buf, p->udp_buffer_.data(), buf_size);\n  p->udp_buffer_.erase(p->udp_buffer_.begin(),\n                       p->udp_buffer_.begin() + buf_size);\n\n  return buf_size;\n}\n\nvoid LibAV::openThread() {\n  int ret;\n  int sleep = 1000 / av_q2d(vstrm_->codec->framerate) - 20;\n  int curr_sleep = sleep;\n  while (1) {\n    // std::cout << \"\\033[36mbuffer size:\" << udp_buffer_.size() << \" \\033[0m\"\n    //           << std::endl;\n    if (mode_ == UDP_STREAM || mode_ == MANUAL_IO) {\n      if (udp_buffer_.size() > 500000)\n        curr_sleep = sleep - 5;\n      else if (udp_buffer_.size() < 50000)\n        curr_sleep = sleep + 5;\n      std::this_thread::sleep_for(std::chrono::milliseconds(curr_sleep));\n\n      while (udp_buffer_.size() < 10000)\n        std::this_thread::sleep_for(std::chrono::milliseconds(20));\n    }\n    // Read packet from input\n    ret = av_read_frame(inctx_, &pkt_);\n    if (ret < 0 && ret != AVERROR_EOF) {\n      std::cerr << \"Faill to read frame. ret=%X\" << -ret << std::endl;\n      av_packet_unref(&pkt_);\n      continue;\n    }\n    if (ret == 0 && pkt_.stream_index != vstrm_idx_) {\n      av_packet_unref(&pkt_);\n      continue;\n    }\n    if (ret == AVERROR_EOF) {\n      av_packet_unref(&pkt_);\n    }\n\n    // Decode video frame\n    avcodec_decode_video2(vstrm_->codec, decframe_, &got_pic_, &pkt_);\n    if (!got_pic_) {\n      av_packet_unref(&pkt_);\n      continue;\n    }\n\n    // Convert frame to OpenCV matrix\n    {\n      std::lock_guard<std::mutex> lock(image_lock_);\n      sws_scale(swsctx_, decframe_->data, decframe_->linesize, 0,\n                decframe_->height, frame_->data, frame_->linesize);\n\n#ifdef USE_ROS\n      // Write to msgs and pub\n      sensor_msgs::ImagePtr ptr = boost::make_shared<sensor_msgs::Image>();\n\n      cv::Mat image(dst_height_, dst_width_, CV_8UC3, framebuf_.data(),\n                    frame_->linesize[0]);\n      ptr = cv_bridge::CvImage(std_msgs::Header(), \"bgr8\", image).toImageMsg();\n      img_pub_.publish(ptr);\n#endif\n    }\n    av_packet_unref(&pkt_);\n  }\n}\n\ncv::Mat LibAV::getMat() {\n  // Convert frame to OpenCV matrix\n  std::lock_guard<std::mutex> lock(image_lock_);\n  cv::Mat image(dst_height_, dst_width_, CV_8UC3, framebuf_.data(),\n                frame_->linesize[0]);\n  return image;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- 3rdparty/libav_Mat/src/libav.cpp	(revision 8114076f8399aadca3d0d2411d59632fe23f4a3c)
+++ 3rdparty/libav_Mat/src/libav.cpp	(date 1596004894170)
@@ -97,6 +97,7 @@
 }
 
 int LibAV::initIOAV(int buffer_size) {
+    std::cout << "initIOAV" << std::endl;
   av_register_all();
   io_buffer_ = NULL;
 
